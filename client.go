/* Copyright (C) 2014 CompleteDB LLC.
 *
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the Apache License Version 2.0 http://www.apache.org/licenses.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.
 *
 */

package pubsubsql

import (
	"container/list"
	"encoding/json"
	"net"
	"time"
)

type Client interface {

	// Connect connects to the pubsubsql server.
	// Address has the form host:port.
	Connect(address string) bool

	// Disconnect disconnects from the pubsubsql server.
	Disconnect()

	// Connected returns true if currently connected to the server.
	Connected() bool

	// Ok determines if last operation succeeded. 
	Ok() bool

	// Failed determines if last operation failed.
	Failed() bool

	// Error returns error string when last operation fails.
	Error() string

	// Execute executes a command.
	// Returns true on success.
	Execute(command string) bool

	// JSON() returns JSON response string returned from the last operation.
	JSON() string

	// Action returns action for last operation.
	// Valid actions [status, insert, upate, delete, add, remove, update, subsribe, unsubscribe]
	Action() string

	// PubSubId returns unique pubsub identifier generated by the database.  
	// Valid for pubsub related actions: subscribe, insert, add, delete, remove, update.
	// PubSubId is generated by pubsubsql server when client subscribes to a table and
	// used to uniqely identify the subscription.
	PubSubId() string

	// RowCount returns number of rows in the returned result set
	// or number of records affected by last executed command. 
	RowCount() int

	// NextRow moves cusrsor to the next data row in the returned result set.    
	// Returns false when all records are read.
	// Must be called initially to position cursor to the first record. 
	NextRow() bool

	// Value returns column value by column name.
	// If column does not exist in current result set it returns empty string.	
	Value(column string) string

	// ValueByOrdinal return value by column ordinal in the returned result set.
	ValueByOrdinal(ordinal int) string

	// Determines if column exist in the current result set.
	HasColumn(column string) bool

	//ColumnCount returns number of columns in the returned resutl set. 
	ColumnCount() int

	// Columns returns an array of valid column names in the current result set. 		
	Columns() []string

	// WaitForPubSub waits until publish message is retreived or timeout expired.
	// Returns false on error or timeout.
	// When timeout expires Ok() will return true.
	WaitForPubSub(timeout int) bool
}

func NewClient() Client {
	var c client
	return &c
}

var CLIENT_DEFAULT_BUFFER_SIZE int = 2048

// respnoseData holds unmarshaled result from pubsubsql JSON response
type responseData struct {
	Status   string
	Msg      string
	Action   string
	Id       string
	PubSubId string
	Rows     int
	Fromrow  int
	Torow    int
	Columns  []string
	Data     [][]string
}

func (this *responseData) reset() {
	this.Status = ""
	this.Msg = ""
	this.Action = ""
	this.PubSubId = ""
	this.Rows = 0
	this.Fromrow = 0
	this.Torow = 0
	this.Columns = nil
	this.Data = nil
}

type client struct {
	Client
	address   string
	rw        NetHelper
	requestId uint32
	err       string
	rawjson   []byte
	//
	response responseData
	record   int
	columns  map[string]int

	// pubsub back log
	backlog list.List
}

func (this *client) Connect(address string) bool {
	this.address = address
	this.Disconnect()
	conn, err := net.DialTimeout("tcp", this.address, time.Millisecond*1000)
	if err != nil {
		this.setError(err)
		return false
	}
	this.rw.Set(conn, CLIENT_DEFAULT_BUFFER_SIZE)
	return true
}

func (this *client) Disconnect() {
	this.write("close")
	// write may generate error so we reset after instead
	this.reset()
	this.rw.Close()
}

func (this *client) Connected() bool {
	return this.rw.Valid()
}

func (this *client) Ok() bool {
	return this.err == ""
}

func (this *client) Failed() bool {
	return !this.Ok()
}

func (this *client) Error() string {
	return this.err
}

func (this *client) Execute(command string) bool {
	this.reset()
	ok := this.write(command)
	var bytes []byte
	var header *NetHeader
	for ok {
		this.reset()
		header, bytes, ok = this.read()
		if !ok {
			break
		}
		if header.RequestId == this.requestId {
			// response we are waiting for
			return this.unmarshalJSON(bytes)
		} else if header.RequestId == 0 {
			// pubsub action, save it and skip it for now
			// will be proccesed next time WaitPubSub is called
			//WE MUST COPY BYTES SINCE THEY ARE REUSED IN NetHelper
			t := make([]byte, header.MessageSize, header.MessageSize)
			copy(t, bytes[0:header.MessageSize])
			this.backlog.PushBack(t)
		} else if header.RequestId < this.requestId {
			// we did not read full result set from previous command ignore it or report error?
			// for now lets ignore it, continue reading until we hit our request id 
			this.reset()
		} else {
			// this should never happen
			this.setErrorString("protocol error invalid requestId")
			ok = false
		}
	}
	return ok
}

func (this *client) JSON() string {
	return string(this.rawjson)
}

func (this *client) Action() string {
	return this.response.Action
}

func (this *client) PubSubId() string {
	return this.response.PubSubId
}

func (this *client) RowCount() int {
	return this.response.Rows
}

func (this *client) NextRow() bool {
	for this.Ok() {
		// no result set
		if this.response.Rows == 0 {
			return false
		}
		if this.response.Fromrow == 0 || this.response.Torow == 0 {
			return false
		}
		// the current record is valid 
		this.record++
		if this.record <= (this.response.Torow - this.response.Fromrow) {
			return true
		}
		// we reached the end of result set
		if this.response.Rows == this.response.Torow {
			// gaurd against over fill
			this.record--
			return false
		}
		// if we are here there is another batch 
		this.reset()
		header, bytes, ok := this.read()
		if !ok {
			return false
		}
		// should not happen but check anyway
		// when RequestId is 0 it means we are reading published data
		if header.RequestId > 0 && header.RequestId != this.requestId {
			this.setErrorString("protocol error")
			return false
		}
		// we got another batch unmarshall the data	
		this.unmarshalJSON(bytes)
	}
	return false
}

func (this *client) Value(column string) string {
	ordinal, ok := this.columns[column]
	if !ok {
		return ""
	}
	return this.ValueByOrdinal(ordinal)
}

func (this *client) ValueByOrdinal(ordinal int) string {
	if this.record < 0 || this.record >= len(this.response.Data) {
		return ""
	}
	if ordinal >= len(this.response.Data[this.record]) {
		return ""
	}
	return this.response.Data[this.record][ordinal]
}

func (this *client) HasColumn(column string) bool {
	_, ok := this.columns[column]
	return ok
}

func (this *client) ColumnCount() int {
	return len(this.response.Columns)
}

func (this *client) Columns() []string {
	return this.response.Columns
}

func (this *client) WaitForPubSub(timeout int) bool {
	var bytes []byte
	for {
		this.reset()
		// process backlog first	
		bytes = this.popBacklog()
		if len(bytes) > 0 {
			return this.unmarshalJSON(bytes)
		}
		header, temp, success, timedout := this.readTimeout(int64(timeout))
		bytes = temp
		if !success || timedout {
			return false
		}
		if header.RequestId == 0 {
			return this.unmarshalJSON(bytes)
		}
		// this is not pubsub message; are we reading abandoned cursor?
		// ignore and keep trying
	}
	return false
}

func (this *client) popBacklog() []byte {
	element := this.backlog.Front()
	if element != nil {
		bytes := element.Value.([]byte)
		this.backlog.Remove(element)
		return bytes
	}
	return nil
}

func (this *client) unmarshalJSON(bytes []byte) bool {
	this.rawjson = bytes
	err := json.Unmarshal(bytes, &this.response)
	if err != nil {
		this.setError(err)
		return false
	}
	if this.response.Status != "ok" {
		this.setErrorString(this.response.Msg)
		return false
	}
	this.setColumns()
	return true
}

func (this *client) setColumns() {
	if len(this.response.Columns) == 0 {
		return
	}
	this.columns = make(map[string]int, cap(this.response.Columns))
	for ordinal, column := range this.response.Columns {
		this.columns[column] = ordinal
	}
}

func (this *client) reset() {
	this.resetError()
	this.response.reset()
	this.rawjson = nil
	this.record = -1
}

func (this *client) resetError() {
	this.err = ""
}

func (this *client) setErrorString(err string) {
	this.reset()
	this.err = err
}

func (this *client) setError(err error) {
	this.setErrorString(err.Error())
}

func (this *client) write(message string) bool {
	this.requestId++
	if !this.rw.Valid() {
		this.setErrorString("Not connected")
		return false
	}
	err := this.rw.WriteHeaderAndMessage(this.requestId, []byte(message))
	if err != nil {
		this.setError(err)
		return false
	}
	return true
}

func (this *client) readTimeout(timeout int64) (*NetHeader, []byte, bool, bool) {
	if !this.rw.Valid() {
		this.setErrorString("Not connected")
		return nil, nil, false, false
	}
	header, bytes, err, timedout := this.rw.ReadMessageTimeout(timeout)
	if timedout {
		return nil, nil, true, true
	}
	// error
	if err != nil {
		this.setError(err)
		return nil, nil, false, false
	}
	// success
	return header, bytes, true, false

}

func (this *client) read() (*NetHeader, []byte, bool) {
	var MAX_READ_TIMEOUT_MILLISECONDS int64 = 1000 * 60 * 3
	header, bytes, success, timedout := this.readTimeout(MAX_READ_TIMEOUT_MILLISECONDS)
	if timedout {
		this.setErrorString("Read timed out")
		return nil, nil, false
	}
	return header, bytes, success
}
